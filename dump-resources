#!/usr/bin/env perl

# !!! This is written specifically for MineColonies structure nbt files.
# !!! There are no checks for invalid data.
# !!! Use at your own peril!

# Use my version of Minecraft::NBTReader found at
# https://github.com/harleypig/Minecraft-NBTReader
#
# I've added support for the TAG_Int_Array type and removed a block for nbt
# files that end with two nulls.

# XXX: Do I need to include the location of the hut block in the output?
# XXX: Do I count 'double wooden slabs' as 2 slabs?

use strict;
use warnings;

#use Data::Dumper;
#use File::Basename;
#use Minecraft::NBTReader;
#use YAML::Syck;
#
#$Data::Dumper::Indent=1;

use MineColonies::Schematic::Read;

#my $method_hash = {
#  author   => sub { simple('author',   @_) },
#  entities => sub { simple('entities', @_) },
#  version  => sub { simple('version',  @_) },
#  size     => sub { simple('size',     @_) },
#
#  dataversion      => sub { 1 },
#  forgedataversion => sub { 1 },
#
#  blocks   => \&blocks,
#  palette  => \&palette,
#
#};

#################################################################################

my $filename = shift or die "Must pass filename.\n";
my $data     = MineColonies::Schematic::Read->new($filename);

#my $data     = read_file($filename);

for my $el ( keys %$data ) {
  my $method = lc $el;

  warn sprintf "unknown method key: %s\n", Dumper $data->{$el}
    unless exists $method_hash->{$method};

  $method_hash->{$method}->($data->{$el});

}

dump_required_resources( $hut_info );

exit;

#################################################################################

sub simple { $hut_info->{$_[0]} = $_[1] }

sub blocks {
  my ( $blocks ) = @_;

  my @blocks_info;

  my @ignore_key = ();

  for my $block ( @$blocks ) {
    my $block_info;

    for my $key ( keys %$block ) {

      if ( $key eq 'pos' ) {
        $block_info->{xyz} = $block->{$key};

      } elsif ( $key eq 'state' ) {
        $block_info->{type} = $block->{$key};
        $hut_info->{count}{$block->{$key}}++;

      } elsif ( $key eq 'nbt' ) {
        #die "multiple nbt's, don't know what to do"
        #  if exists $hut_info->{hut_pos};

        if ( exists $hut_info->{hut_pos} ) {
          # Don't do anything with extra nbt's at all.
          #warn "multiple nbt's, not doing anything with this key";
        } else {
          $hut_info->{hut_pos} = $block->{pos};
        }

      } else {
        warn "uknown key ($key) in blocks\n"
          unless grep {$key} @ignore_key;

      }
    }

    push @blocks_info, $block_info;

  }

  $hut_info->{block_matrix} = \@blocks_info;

}

sub palette {
  my ( $types ) = @_;

  for my $type ( @$types ) {
    my $string = $type->{Name};

    $string =~ s/^minecraft://;

    # Special cases.

    $string =~ s/_+/ /g;
    $string =~ s/^log2$/log/;
    $string =~ s/^fence$/oak fence/;

    # Skip variants of these values.

    my @skip_variant = qw(
      default
      lines_x
      lines_y
      lines_z
    );

    if ( exists $type->{Properties} ) {
      my $props   = $type->{Properties};
      my $variant = exists $props->{variant} ? $props->{variant} : '';
      my $color   = exists $props->{color}   ? $props->{color}   : '';

      if ( $variant ne '' && ! grep { /$variant/ } @skip_variant ) {

        $variant =~ s/_+/ /g;

        # Avoid 'dirt dirt' or 'cracked stonebrick stonebrick'
        $string = $variant =~ /$string/ ? $variant : "$variant $string";

      }

      $string = "$color $string"
        unless $color eq '';

    }

    $type->{string} = $string;

  }

  $hut_info->{block_types} = $types;

}

#################################################################################

#sub read_file {
#  my ( $filename ) = @_;
#  my $r = Minecraft::NBTReader->new;
#  my %d = $r->readFile($filename);
#
#  my $expected_root_key = 'unnamed_0000001';
#
#  die "unexpected root key\n"
#    unless exists $d{$expected_root_key};
#
#  return $d{$expected_root_key};
#
#}

#################################################################################

sub dump_required_resources {
  my ( $hut_info ) = @_;

  my $hut_name    = hut_name();
  my $hut_details = hut_details( $hut_info );
  #my $hut_outline = hut_outline( $hut_info );

  my ( $res_fmt, $resources ) = hut_resources( $hut_info );

  printf "%s\n\n%s\n\n%s\n\n", $hut_name, $hut_details, '-' x 40;
  printf $res_fmt, $_, $resources->{$_} for sort keys %$resources;

}

#sub hut_name {
#  my ( $name, $path, $suffix ) = fileparse($filename, '.nbt');
#  $path =~ s{^.*/(\w*)/$}{$1};
#  return sprintf '%s %s', $path, $name;
#}
#
#sub hut_details {
#  my ( $hut_info ) = @_;
#
#  my $join = sub { join ' x ', map { sprintf "%2d", $_ } @{$_[0]} };
#
#  my $hut_size_txt = 'Size (xyz):';
#  my $hut_size_len = length $hut_size_txt;
#  my $hut_size_val = $join->($hut_info->{size});
#
#  #my $hut_pos_txt = 'Hut Location (xyz):';
#  #my $hut_pos_len = length $hut_pos_txt;
#  #my $hut_pos_val = $join->($hut_info->{hut_pos});
#
#  #my $info_pad = $hut_size_len > $hut_pos_len ? $hut_size_len : $hut_pos_len;
#  my $info_pad = $hut_size_len;
#
#  my $hut_size = sprintf "  %${info_pad}s %s", $hut_size_txt, $hut_size_val;
#  #my $hut_pos  = sprintf "  %${info_pad}s %s", $hut_pos_txt,  $hut_pos_val;
#
#  #return "$hut_size\n$hut_pos";
#  return $hut_size;
#
#}
#
#sub hut_resources {
#  my ( $hut_info ) = @_;
#
#  my $resources;
#
#  my @ignore = qw(
#    minecraft:air
#    minecolonies:blockSubstitution
#    minecolonies:blockSolidSubstitution
#  );
#
#  my $max_string_len = -1;
#  my $max_count_len  = -1;
#
#  for my $type ( keys %{$hut_info->{count}} ) {
#    my $name   = $hut_info->{block_types}[$type]{Name};
#
#    next if grep { /$name/ } @ignore;
#    next if $name =~ /^minecolonies:blockHut/;
#
#    my $count  = $hut_info->{count}{$type};
#    my $string = $hut_info->{block_types}[$type]{string};
#
#    # Special cases
#    if ( $string =~ /double wooden slab$/ ) {
#      $string =~ s/double //;
#      $resources->{$string} += $count;
#
#    }
#
#    $resources->{$string} += $count;
#
#    $max_string_len = length $string
#      if $max_string_len < length $string;
#
#    $max_count_len = length $count
#      if $max_count_len < length $count;
#
#  }
#
#  my $hut_res_fmt = "  %${max_string_len}s: %${max_count_len}d\n";
#
#  return ( $hut_res_fmt, $resources );
#
#}
