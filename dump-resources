#!/usr/bin/env perl

# !!! This is written specifically for MineColonies structure nbt files.
# !!! There are no checks for invalid data.
# !!! Use at your own peril!

# Use my version of Minecraft::NBTReader found at
# https://github.com/harleypig/Minecraft-NBTReader
#
# I've added support for the TAG_Int_Array type and removed a block for nbt
# files that end with two nulls.

# XXX: Do I need to include the location of the hut block in the output?
# XXX: Do I count 'double wooden slabs' as 2 slabs?

use strict;
use warnings;

#use Data::Dumper;
use File::Basename;
#use Minecraft::NBTReader;
#use YAML::Syck;
#
#$Data::Dumper::Indent=1;

use lib '.';
use MineColonies::Schematic::Load;
use MineColonies::Schematic::Parse;

#################################################################################

my $filename = shift or die "Must pass filename.\n";
my $data     = MineColonies::Schematic::Load::read_file($filename);
my $hut_info = MineColonies::Schematic::Parse::parse_data($data);

dump_required_resources( $hut_info );

exit;

#################################################################################

sub dump_required_resources {
  my ( $hut_info ) = @_;

  my $hut_name    = hut_name();
  my $hut_details = hut_details( $hut_info );
  #my $hut_outline = hut_outline( $hut_info );

  my ( $res_fmt, $resources ) = hut_resources( $hut_info );

  printf "%s\n\n%s\n\n%s\n\n", $hut_name, $hut_details, '-' x 40;
  printf $res_fmt, $_, $resources->{$_} for sort keys %$resources;

}

sub hut_name {
  my ( $name, $path, $suffix ) = fileparse($filename, '.nbt');
  $path =~ s{^.*/(\w*)/$}{$1};
  return sprintf '%s %s', $path, $name;
}

sub hut_details {
  my ( $hut_info ) = @_;

  my $join = sub { join ' x ', map { sprintf "%2d", $_ } @{$_[0]} };

  my $hut_size_txt = 'Size (xyz):';
  my $hut_size_len = length $hut_size_txt;
  my $hut_size_val = $join->($hut_info->{size});

  #my $hut_pos_txt = 'Hut Location (xyz):';
  #my $hut_pos_len = length $hut_pos_txt;
  #my $hut_pos_val = $join->($hut_info->{hut_pos});

  #my $info_pad = $hut_size_len > $hut_pos_len ? $hut_size_len : $hut_pos_len;
  my $info_pad = $hut_size_len;

  my $hut_size = sprintf "  %${info_pad}s %s", $hut_size_txt, $hut_size_val;
  #my $hut_pos  = sprintf "  %${info_pad}s %s", $hut_pos_txt,  $hut_pos_val;

  #return "$hut_size\n$hut_pos";
  return $hut_size;

}

sub hut_resources {
  my ( $hut_info ) = @_;

  my $resources;

  my @ignore = qw(
    minecraft:air
    minecolonies:blockSubstitution
    minecolonies:blockSolidSubstitution
  );

  my $max_string_len = -1;
  my $max_count_len  = -1;

  for my $type ( keys %{$hut_info->{count}} ) {
    my $name   = $hut_info->{block_types}[$type]{Name};

    next if grep { /$name/ } @ignore;
    next if $name =~ /^minecolonies:blockHut/;

    my $count  = $hut_info->{count}{$type};
    my $string = $hut_info->{block_types}[$type]{string};

    # Special cases
    if ( $string =~ /double wooden slab$/ ) {
      $string =~ s/double //;
      $resources->{$string} += $count;

    }

    $resources->{$string} += $count;

    $max_string_len = length $string
      if $max_string_len < length $string;

    $max_count_len = length $count
      if $max_count_len < length $count;

  }

  my $hut_res_fmt = "  %${max_string_len}s: %${max_count_len}d\n";

  return ( $hut_res_fmt, $resources );

}
